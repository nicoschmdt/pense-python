<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Iteração - Pense em Python</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Pense como um cientista da computação">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introducao.html">Pense em Python</a></li><li class="affix"><a href="00-prefacio.html">Prefácio</a></li><li><a href="01-jornada.html"><strong aria-hidden="true">1.</strong> A jornada do programa</a></li><li><a href="02-vars-expr-instr.html"><strong aria-hidden="true">2.</strong> Variáveis, expressões e instruções</a></li><li><a href="03-funcoes.html"><strong aria-hidden="true">3.</strong> Funções</a></li><li><a href="04-caso-interface.html"><strong aria-hidden="true">4.</strong> Estudo de caso: projeto de interface</a></li><li><a href="05-cond-recur.html"><strong aria-hidden="true">5.</strong> Condicionais e recursividade</a></li><li><a href="06-funcoes-result.html"><strong aria-hidden="true">6.</strong> Funções com resultado</a></li><li><a href="07-iteracao.html" class="active"><strong aria-hidden="true">7.</strong> Iteração</a></li><li><a href="08-strings.html"><strong aria-hidden="true">8.</strong> Strings</a></li><li><a href="09-caso-palavras.html"><strong aria-hidden="true">9.</strong> Estudo de caso: jogos de palavras</a></li><li><a href="10-listas.html"><strong aria-hidden="true">10.</strong> Listas</a></li><li><a href="11-dicionarios.html"><strong aria-hidden="true">11.</strong> Dicionários</a></li><li><a href="12-tuplas.html"><strong aria-hidden="true">12.</strong> Tuplas</a></li><li><a href="13-caso-estruturas.html"><strong aria-hidden="true">13.</strong> Estudo de caso: seleção de estrutura de dados</a></li><li><a href="14-arquivos.html"><strong aria-hidden="true">14.</strong> Arquivos</a></li><li><a href="15-classes-objetos.html"><strong aria-hidden="true">15.</strong> Classes e objetos</a></li><li><a href="16-classes-funcoes.html"><strong aria-hidden="true">16.</strong> Classes e funções</a></li><li><a href="17-classes-metodos.html"><strong aria-hidden="true">17.</strong> Classes e métodos</a></li><li><a href="18-heranca.html"><strong aria-hidden="true">18.</strong> Herança</a></li><li><a href="19-extra.html"><strong aria-hidden="true">19.</strong> Extra</a></li><li class="affix"><a href="A-depuracao.html">Apêndice A: Depuração</a></li><li class="affix"><a href="B-analise-algorit.html">Apêndice B: Análise de algoritmos</a></li><li class="affix"><a href="C-colofao-autor.html">Colofão / Sobre o Autor</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Pense em Python</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="07-iteracao.html#capítulo-7-iteração" id="capítulo-7-iteração"><h1>Capítulo 7: Iteração</h1></a>
<p>Este capítulo é sobre a iteração, a capacidade de executar um bloco de instruções repetidamente. Vimos um tipo de iteração, usando a recursividade, em “Recursividade”, na página 81. Vimos outro tipo, usando um loop for, em “Repetição simples”, na página 65. Neste capítulo veremos ainda outro tipo, usando a instrução while. Porém, primeiro quero falar um pouco mais sobre a atribuição de variáveis.</p>
<a class="header" href="07-iteracao.html#71---reatribuição" id="71---reatribuição"><h2>7.1 - Reatribuição</h2></a>
<p>Pode ser que você já tenha descoberto que é permitido fazer mais de uma atribuição para a mesma variável. Uma nova atribuição faz uma variável existente referir-se a um novo valor (e deixar de referir-se ao valor anterior).</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x
5
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; x
7
</code></pre>
<p>A primeira vez que exibimos x, seu valor é 5; na segunda vez, seu valor é 7.</p>
<p>A Figura 7.1 mostra que a reatribuição parece um diagrama de estado.</p>
<p>Neste ponto quero tratar de uma fonte comum de confusão. Como o Python usa o sinal de igual (=) para atribuição, é tentador interpretar uma afirmação como a = b como uma proposição matemática de igualdade; isto é, a declaração de que a e b são iguais. Mas esta é uma interpretação equivocada.</p>
<p>Em primeiro lugar, a igualdade é uma relação simétrica e a atribuição não é. Por exemplo, na matemática, se a=7 então 7=a. Mas no Python, a instrução a = 7 é legal e 7 = a não é.</p>
<p>Além disso, na matemática, uma proposição de igualdade é verdadeira ou falsa para sempre. Se a=b agora, então a sempre será igual a b. No Python, uma instrução de atribuição pode tornar duas variáveis iguais, mas elas não precisam se manter assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = a    # a e b agora são iguais
&gt;&gt;&gt; a = 3    # a e b não são mais iguais
&gt;&gt;&gt; b
5
</code></pre>
<p>A terceira linha modifica o valor de a, mas não muda o valor de b, então elas já não são iguais.</p>
<p>A reatribuição de variáveis muitas vezes é útil, mas você deve usá-la com prudência. Se os valores das variáveis mudarem frequentemente, isso pode dificultar a leitura e depuração do código.</p>
<pre><code class="language-python">Figura 7.1 – Diagrama de estado.
</code></pre>
<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0701.png" alt="Figura 7.1 – Diagrama de estado da variável x." />
<br><em>Figura 7.1 – Diagrama de estado da variável x.</em></p>
<a class="header" href="07-iteracao.html#72---atualização-de-variáveis" id="72---atualização-de-variáveis"><h2>7.2 - Atualização de variáveis</h2></a>
<p>Um tipo comum de reatribuição é uma atualização, onde o novo valor da variável depende do velho.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = x + 1
</code></pre>
<p>Isso significa “pegue o valor atual de x, acrescente um, e então atualize x para o novo valor”.</p>
<p>Se você tentar atualizar uma variável que não existe, recebe um erro porque o Python avalia o lado direito antes de atribuir um valor a x:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = x + 1
NameError: name 'x' is not defined
</code></pre>
<p>Antes de poder atualizar uma variável é preciso inicializá-la, normalmente com uma atribuição simples:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1
</code></pre>
<p>Atualizar uma variável acrescentando 1 chama-se incremento; subtrair 1 chama-se decremento.</p>
<a class="header" href="07-iteracao.html#73---instrução-while" id="73---instrução-while"><h2>7.3 - Instrução while</h2></a>
<p>Os computadores muitas vezes são usados para automatizar tarefas repetitivas. A repetição de tarefas idênticas ou semelhantes sem fazer erros é algo que os computadores fazem bem e as pessoas não. Em um programa de computador, a repetição também é chamada de iteração.</p>
<p>Já vimos duas funções, <code>countdown</code> e <code>print_n</code>, que se repetem usando recursividade. Como a iteração é bem comum, o Python fornece recursos de linguagem para facilitá-la. Um deles é a instrução <code>for</code> que vimos em “Repetição simples”, na página 65. Voltaremos a isso mais adiante.</p>
<p>Outra é a instrução <code>while</code>. Aqui está uma versão de countdown que usa a instrução <code>while</code>:</p>
<pre><code class="language-python">def countdown(n):
    while n &gt; 0:
        print(n)
        n = n - 1
    print('Blastoff!')
</code></pre>
<p>Você até pode ler a instrução <code>while</code> como se fosse uma tradução do inglês. Significa “Enquanto <code>n</code> for maior que 0, mostre o valor de <code>n</code> e então decremente <code>n</code>. Quando chegar a 0, mostre a palavra Blastoff!”</p>
<p>Mais formalmente, aqui está o fluxo de execução para uma instrução while:</p>
<ol>
<li>
<p>Determine se a condição é verdadeira ou falsa.</p>
</li>
<li>
<p>Se for falsa, saia da instrução while e continue a execução da próxima instrução.</p>
</li>
<li>
<p>Se a condição for verdadeira, execute o corpo e então volte ao passo 1.</p>
</li>
</ol>
<p>Este tipo de fluxo chama-se loop (laço), porque o terceiro passo faz um loop de volta ao topo.</p>
<p>O corpo do loop deve mudar o valor de uma ou mais variáveis para que, a certa altura, a condição fique falsa e o loop termine. Senão o loop vai se repetir para sempre, o que é chamado de loop infinito. Uma fonte infindável de divertimento para cientistas da computação é a observação das instruções no xampu, “Faça espuma, enxágue, repita”, que são parte de um loop infinito.</p>
<p>No caso de countdown, podemos provar que o loop termina: se <code>n</code> for zero ou negativo, o loop nunca é executado. Senão, <code>n</code> fica cada vez menor ao passar pelo loop, até eventualmente chegar a 0.</p>
<p>Para alguns outros loops, não é tão fácil perceber isso. Por exemplo:</p>
<pre><code class="language-python">def sequence(n):
    while n != 1:
        print(n)
        if n % 2 == 0:        # n é par
            n = n / 2
        else:                 # n é ímpar
            n = n * 3 + 1
</code></pre>
<p>A condição deste loop é <code>n != 1</code>, então o loop continuará até que <code>n</code> seja 1, o que torna a condição falsa.</p>
<p>Cada vez que passa pelo loop, o programa produz o valor de <code>n</code> e então verifica se é par ou ímpar. Se for par, <code>n</code> é dividido por 2. Se for ímpar, o valor de <code>n</code> é substituído por <code>n * 3 + 1</code>. Por exemplo, se o argumento passado a sequence for 3, os valores resultantes de <code>n</code> são 3, 10, 5, 16, 8, 4, 2, 1.</p>
<p>Como <code>n</code> às vezes aumenta e às vezes diminui, não há nenhuma prova óbvia de que <code>n</code> chegará eventualmente a 1, ou que o programa terminará. Para alguns valores de <code>n</code>, podemos provar o término. Por exemplo, se o valor inicial for uma potência de dois, <code>n</code> será par cada vez que passar pelo loop até que chegue a 1. O exemplo anterior termina com uma sequência assim, que inicia com 16.</p>
<p>A questão difícil é se podemos provar que este programa termina para todos os valores positivos de <code>n</code>. Por enquanto, ninguém foi capaz de comprovar ou refutar isso! (Veja http://en.wikipedia.org/wiki/Collatz_conjecture.)</p>
<p>Como um exercício, reescreva a função print_n de “Recursividade”, na página 81, usando a iteração em vez da recursividade.</p>
<a class="header" href="07-iteracao.html#74---break" id="74---break"><h2>7.4 - break</h2></a>
<p>Às vezes você não sabe que está na hora de terminar um loop até que já esteja na metade do corpo. Neste caso pode usar a instrução break para sair do loop.</p>
<p>Por exemplo, suponha que você quer receber uma entrada do usuário até que este digite done. Você pode escrever:</p>
<pre><code class="language-python">while True:
    line = input('&gt; ')
    if line == 'done':
        break
    print(line)
print('Done!')
</code></pre>
<p>A condição do loop é True, que sempre é verdade, então o loop roda até que chegue à instrução de interrupção.</p>
<p>Cada vez que passa pelo loop, o programa apresenta ao usuário um colchete angular. Se o usuário digitar done, a instrução break sai do loop. Senão, o programa ecoa o que quer que o usuário digite e volta ao topo do loop. Aqui está uma amostra de execução:</p>
<pre><code class="language-python">&gt; not done
not done
&gt; done
Done!
</code></pre>
<p>Esta forma de escrever loops while é comum porque podemos verificar a condição em qualquer lugar do loop (não somente no topo) e podemos exprimir a condição de parada afirmativamente (“pare quando isto acontecer”) em vez de negativamente (“continue a seguir até que isto aconteça”).</p>
<a class="header" href="07-iteracao.html#75---raízes-quadradas" id="75---raízes-quadradas"><h2>7.5 - Raízes quadradas</h2></a>
<p>Loops muitas vezes são usados em programas que calculam resultados numéricos, começando com uma resposta aproximada e melhorando-a iterativamente.</p>
<p>Por exemplo, uma forma de calcular raízes quadradas é o método de Newton. Suponha que você queira saber a raiz quadrada de a. Se começar com quase qualquer estimativa, x, é possível calcular uma estimativa melhor com a seguinte fórmula:</p>
<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p79f1.png" alt="Fórmula – Raiz quadrada pelo método de Newton." /></p>
<pre><code class="language-python">Por exemplo, se a for 4 e x for 3:
&gt;&gt;&gt; a = 4
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.16666666667
</code></pre>
<p>O resultado é mais próximo à resposta correta (<img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p79f2.png" alt="Fórmula – Raiz quadrada de 4." /> = 2). Se repetirmos o processo com a nova estimativa, chegamos ainda mais perto:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00641025641
</code></pre>
<p>Depois de algumas atualizações, a estimativa é quase exata:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00001024003
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00000000003
</code></pre>
<p>Em geral, não sabemos com antecedência quantos passos são necessários para chegar à resposta correta, mas sabemos quando chegamos lá porque a estimativa para de mudar:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
</code></pre>
<p>Quando y == x, podemos parar. Aqui está um loop que começa com uma estimativa inicial, x, e a melhora até que deixe de mudar:</p>
<pre><code class="language-python">while True:
    print(x)
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
</code></pre>
<p>Para a maior parte de valores de <code>a</code> funciona bem, mas pode ser perigoso testar a igualdade de um float. Os valores de ponto flutuante são aproximadamente corretos: a maioria dos números racionais, como 1/3, e números irracionais, como <img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p80f1.png" alt="Fórmula – Raiz quadrada de 2." />, não podem ser representados exatamente com um float.</p>
<p>Em vez de verificar se <code>x</code> e <code>y</code> são exatamente iguais, é mais seguro usar a função integrada <code>abs</code> para calcular o valor absoluto ou magnitude da diferença entre eles:</p>
<pre><code class="language-python">if abs(y-x) &lt; epsilon:
    break
</code></pre>
<p>Onde <code>epsilon</code> tem um valor como 0.0000001, que determina a proximidade desejada entre <code>x</code> e <code>y</code>.</p>
<a class="header" href="07-iteracao.html#76---algoritmos" id="76---algoritmos"><h2>7.6 - Algoritmos</h2></a>
<p>O método de Newton é um exemplo de um algoritmo: um processo mecânico para resolver uma categoria de problemas (neste caso, calcular raízes quadradas).</p>
<p>Para entender o que é um algoritmo, pode ser útil começar com algo que não é um algoritmo. Quando aprendeu a multiplicar números de um dígito, você provavelmente memorizou a tabuada. Ou seja, você memorizou 100 soluções específicas. Este tipo de conhecimento não é algorítmico.</p>
<p>No entanto, se você foi “preguiçoso”, poderia ter aprendido alguns truques. Por exemplo, para encontrar o produto de <code>n</code> e 9, pode escrever <code>n-1</code> como o primeiro dígito e <code>10-n</code> como o segundo dígito. Este truque é uma solução geral para multiplicar qualquer número de dígito único por 9. Isto é um algoritmo!</p>
<p>De forma semelhante, as técnicas que aprendeu, como o transporte na adição, o empréstimo na subtração e a divisão longa são todos algoritmos. Uma das características de algoritmos é que eles não exigem inteligência para serem executados. São processos mecânicos, nos quais cada passo segue a partir do último, de acordo com um conjunto de regras simples.</p>
<p>A execução de algoritmos é maçante, mas projetá-los é interessante, intelectualmente desafiador e uma parte central da Ciência da Computação.</p>
<p>Algumas coisas que as pessoas fazem naturalmente, sem dificuldade ou pensamento consciente, são as mais difíceis para exprimir algoritmicamente. A compreensão de linguagem natural é um bom exemplo. Todos nós o fazemos, mas por enquanto ninguém foi capaz de explicar como o fazemos, pelo menos não na forma de um algoritmo.</p>
<a class="header" href="07-iteracao.html#77---depuração" id="77---depuração"><h2>7.7 - Depuração</h2></a>
<p>Ao começar a escrever programas maiores, pode ser que você passe mais tempo depurando. Mais código significa mais possibilidades fazer erros e mais lugares para esconder defeitos.</p>
<p>Uma forma de cortar o tempo de depuração é “depurar por bisseção”. Por exemplo, se há 100 linhas no seu programa e você as verifica uma a uma, seriam 100 passos a tomar.</p>
<p>Em vez disso, tente quebrar o problema pela metade. Olhe para o meio do programa, ou perto disso, para um valor intermediário que possa verificar. Acrescente uma instrução print (ou outra coisa que tenha um efeito verificável) e execute o programa.</p>
<p>Se a verificação do ponto central for incorreta, deve haver um problema na primeira metade do programa. Se for correta, o problema está na segunda metade.</p>
<p>Cada vez que executar uma verificação assim, divida ao meio o número de linhas a serem verificadas. Depois de seis passos (que é menos de 100), você teria menos de uma ou duas linhas do código para verificar, pelo menos em teoria.</p>
<p>Na prática, nem sempre é claro o que representa o “meio do programa” e nem sempre é possível verificá-lo. Não faz sentido contar linhas e encontrar o ponto central exato. Em vez disso, pense em lugares no programa onde poderia haver erros e lugares onde é fácil inserir um ponto de verificação. Então escolha um lugar onde as possibilidades são basicamente as mesmas de que o defeito esteja antes ou depois da verificação.</p>
<a class="header" href="07-iteracao.html#78---glossário" id="78---glossário"><h2>7.8 - Glossário</h2></a>
<dl>
<dt><a id="glos:reatribuição" href="07-iteracao.html#termo:reatribuição">reatribuição</a></dt>
<dd>Atribuir um novo valor a uma variável que já existe.</dd>
<dt><a id="glos:atualização" href="07-iteracao.html#termo:atualização">atualização</a></dt>
<dd>Uma atribuição onde o novo valor da variável dependa do velho.</dd>
<dt><a id="glos:inicialização" href="07-iteracao.html#termo:inicialização">inicialização</a></dt>
<dd>Uma atribuição que dá um valor inicial a uma variável que será atualizada.</dd>
<dt><a id="glos:incremento" href="07-iteracao.html#termo:incremento">incremento</a></dt>
<dd>Uma atualização que aumenta o valor de uma variável (normalmente por uma unidade).</dd>
<dt><a id="glos:decremento" href="07-iteracao.html#termo:decremento">decremento</a></dt>
<dd>Uma atualização que reduz o valor de uma variável.</dd>
<dt><a id="glos:iteração" href="07-iteracao.html#termo:iteração">iteração</a></dt>
<dd>Execução repetida de um grupo de instruções, usando uma chamada da função recursiva ou um loop.</dd>
<dt><a id="glos:loop infinito" href="07-iteracao.html#termo:loop infinito">loop infinito</a></dt>
<dd>Um loop no qual a condição de término nunca é satisfeita.</dd>
<dt><a id="glos:algoritmo" href="07-iteracao.html#termo:algoritmo">algoritmo</a></dt>
<dd>Um processo geral para resolver uma categoria de problemas.</dd>
</dl>
<a class="header" href="07-iteracao.html#79---exercícios" id="79---exercícios"><h2>7.9 - Exercícios</h2></a>
<a class="header" href="07-iteracao.html#exercício-71" id="exercício-71"><h3>Exercício 7.1</h3></a>
<p>Copie o loop de “Raízes quadradas”, na página 111, e encapsule-o em uma função chamada <code>mysqrt</code> que receba a como parâmetro, escolha um valor razoável de x e devolva uma estimativa da raiz quadrada de a.</p>
<p>Para testar, escreva uma função denominada <code>test_square_root</code>, que exibe uma tabela como esta:</p>
<pre><code class="language-python">a   mysqrt(a)     math.sqrt(a)  diff
-   ---------     ------------  ----
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0
</code></pre>
<p>A primeira coluna é um número, <code>a</code>; a segunda coluna é a raiz quadrada de a calculada com <code>mysqrt</code>; a terceira coluna é a raiz quadrada calculada por <code>math.sqrt</code>; a quarta coluna é o valor absoluto da diferença entre as duas estimativas.</p>
<a class="header" href="07-iteracao.html#exercício-72" id="exercício-72"><h3>Exercício 7.2</h3></a>
<p>A função integrada <code>eval</code> toma uma string e a avalia, usando o interpretador do Python. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; eval('1 + 2 * 3')
7
&gt;&gt;&gt; import math
&gt;&gt;&gt; eval('math.sqrt(5)')
2.2360679774997898
&gt;&gt;&gt; eval('type(math.pi)')
&lt;class 'float'&gt;
</code></pre>
<p>Escreva uma função chamada <code>eval_loop</code> que iterativamente peça uma entrada ao usuário, a avalie usando <code>eval</code> e exiba o resultado.</p>
<p>Ela deve continuar até que o usuário digite <code>done</code>; então deverá exibir o valor da última expressão avaliada.</p>
<a class="header" href="07-iteracao.html#exercício-73" id="exercício-73"><h3>Exercício 7.3</h3></a>
<p>O matemático Srinivasa Ramanujan encontrou uma série infinita que pode ser usada para gerar uma aproximação numérica de 1/π:</p>
<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p83f1.png" alt="Fórmula – Aproximação de π pela série de Ramanujan." /></p>
<p>Escreva uma função chamada <code>estimate_pi</code> que use esta fórmula para computar e devolver uma estimativa de π. Você deve usar o loop <code>while</code> para calcular os termos da adição até que o último termo seja menor que 1e-15 (que é a notação do Python para <code>10 ** 15</code>). Você pode verificar o resultado comparando-o com <code>math.pi</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="06-funcoes-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="08-strings.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="06-funcoes-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="08-strings.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
